/*
 * This file was generated by the Gradle 'init' task.
 *
 * This generated file contains a sample Java application project to get you started.
 * For more details on building Java & JVM projects, please refer to https://docs.gradle.org/8.10.2/userguide/building_java_projects.html in the Gradle documentation.
 */

plugins {
    // Apply the application plugin to add support for building a CLI application in Java.
    application
    jacoco
}

repositories {
    // Use Maven Central for resolving dependencies.
    mavenCentral()
}

dependencies {
    // Use JUnit Jupiter for testing.
    testImplementation(libs.junit.jupiter)

    testRuntimeOnly("org.junit.platform:junit-platform-launcher")

    // This dependency is used by the application.
    implementation("com.google.code.gson:gson:2.12.1")
    implementation("info.picocli:picocli:4.7.6")
    implementation("info.picocli:picocli-shell-jline3:4.7.6")
    implementation("org.jline:jline-terminal:3.16.0")
    implementation("org.jline:jline-reader:3.16.0")
}

// Apply a specific Java toolchain to ease working on different environments.
java {
    toolchain {
        languageVersion = JavaLanguageVersion.of(21)
    }
}

application {
    // Define the main class for the application.
    mainClass = "org.UMLClassEditorApp"
}

tasks.named<Test>("test") {
    // Use JUnit Platform for unit tests.
    maxParallelForks = Runtime.getRuntime().availableProcessors()
    useJUnitPlatform()
    finalizedBy(tasks.jacocoTestReport) // report is always generated after tests run
}
tasks.jacocoTestReport {
    dependsOn(tasks.test) // tests are required to run before generating the report
    reports {
        xml.required.set(true)
        html.required.set(true)
    }
}

tasks.named<JavaExec>("run") {
}

tasks.register<JavaExec>("run-cli") {
    standardInput = System.`in`
    classpath = sourceSets.main.get().runtimeClasspath
    mainClass.set(application.mainClass.get())
    args("--cli")
}

tasks.register("checkModelCoverage") {
    dependsOn("jacocoTestReport")
    doLast {
        val reportFile = file("app/build/reports/jacoco/test/jacocoTestReport.xml")
        if (!reportFile.exists()) throw GradleException("Coverage report not found")

        val xml = javax.xml.parsers.DocumentBuilderFactory.newInstance()
            .newDocumentBuilder().parse(reportFile)
        xml.documentElement.normalize()

        val counters = xml.getElementsByTagName("package")
        var totalMissed = 0
        var totalCovered = 0

        for (i in 0 until counters.length) {
            val pkg = counters.item(i)
            val name = pkg.attributes.getNamedItem("name").nodeValue
            if (name.startsWith("org/Model")) {
                val children = pkg.childNodes
                for (j in 0 until children.length) {
                    val node = children.item(j)
                    if (node.nodeName == "counter" && node.attributes.getNamedItem("type").nodeValue == "INSTRUCTION") {
                        totalMissed += node.attributes.getNamedItem("missed").nodeValue.toInt()
                        totalCovered += node.attributes.getNamedItem("covered").nodeValue.toInt()
                    }
                }
            }
        }

        if (totalMissed > 0) {
            throw GradleException("Model package coverage is not 100%! Missed: $totalMissed, Covered: $totalCovered")
        } else {
            println("Model package has 100% instruction coverage.")
        }
    }
}
